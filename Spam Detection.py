# -*- coding: utf-8 -*-
"""q3main.py
Automatically generated by Colaboratory.
"""

import itertools
import pandas as pd
import numpy as np
import time

np.seterr(divide='ignore')


class Classifiers:
    def __init__(self):
        self.nonspam_prob = 0
        self.spam_prob = 0
        self.sum_over_all_values_nonspam = 0
        self.sum_over_all_values_spam = 0
        self.each_item_prob = None
        self.each_item_prob_T = None

    @staticmethod
    def change_to_binary(df):
        for i, j in itertools.product(range(df.shape[0]), range(df.shape[1])):
            df[i, j] = min(df[i, j], 1)
        return df

    @staticmethod
    def class_separation(d_x, d_y, arg2):
        result = d_x[d_y['label'] == arg2]
        result.reset_index(inplace=True)
        del result["level_0"]
        return result

    @staticmethod
    def confusion_matrix(pred, original):
        matrix = np.zeros((2, 2))  # form an empty matric of 2x2
        for i in range(len(pred)):  # the confusion matrix is for 2 classes: 1,0
            # 1=positive, true, 0=negative, false
            if int(pred[i]) == 1 and int(original[i]) == 1:
                matrix[0, 0] += 1  # True Positives
            elif int(pred[i]) == 1 and int(original[i]) == 0:
                matrix[0, 1] += 1  # False Positives
            elif int(pred[i]) == 0 and int(original[i]) == 1:
                matrix[1, 0] += 1  # False Negatives
            elif int(pred[i]) == 0 and int(original[i]) == 0:
                matrix[1, 1] += 1  # True Negatives
        precision = matrix[0, 0] / (matrix[0, 0] + matrix[0, 1])
        print("Precision:", precision)
        recall = matrix[0, 0] / (matrix[0, 0] + matrix[1, 0])
        print("Recall:", recall)
        specificity = matrix[1, 1] / (matrix[0, 1] + matrix[1, 1])
        print("Specificity:", specificity)
        # negative_pred_value=matrix[1,1]/(matrix[1,0]+matrix[1,1])
        # print("Negative Predicted Value:",negative_pred_value)
        f1 = 2 * (precision * recall) / (precision + recall)
        print("F1 score:", f1)
        accuracy = (matrix[0, 0] + matrix[1, 1]) / (matrix[0, 0] + matrix[1, 1] + matrix[1, 0] + matrix[0, 1])
        print("accuracy:", accuracy)

        return matrix

    def train_multinomial(self, d_x, d_y):
        self.nonspam_prob = ((d_y['label'] == 0).sum()) / len(d_x.index)
        self.spam_prob = ((d_y['label'] == 1).sum()) / len(d_x.index)

        df_x_Nonspam = self.class_separation(d_x, d_y, 0)
        df_x_spam = self.class_separation(d_x, d_y, 1)

        self.sum_over_all_values_nonspam = df_x_Nonspam.values.sum()
        self.sum_over_all_values_spam = df_x_spam.values.sum()

        columns_name = df_x_Nonspam.columns
        self.each_item_prob = pd.DataFrame(np.zeros((2, len(columns_name))), columns=columns_name)

        for i, names in enumerate(columns_name):
            self.each_item_prob.iloc[0, i] = df_x_Nonspam[names].sum() / self.sum_over_all_values_nonspam
            self.each_item_prob.iloc[1, i] = df_x_spam[names].sum() / self.sum_over_all_values_spam

        self.each_item_prob = self.each_item_prob.applymap(lambda x: np.log(x))
        self.each_item_prob.replace([np.inf, -np.inf], -(10 ** 12), inplace=True)
        self.each_item_prob_T = self.each_item_prob.transpose()

        print("Multinomial Naive Bayes model is trained successfully.")

    def predict_multinomial(self, d_x):

        df_rt = d_x @ (self.each_item_prob_T)

        df_rt[0] = df_rt[0] + np.log(self.nonspam_prob)
        df_rt[1] = df_rt[1] + np.log(self.spam_prob)

        df_rt["predicted_label"] = df_rt[[0, 1]].apply(lambda x: 0 if x[0] == x[1] else x.idxmax(), axis=1)

        return df_rt

    def train_multinomial_smoothing(self, d_x, d_y):
        a = 5
        V = len(d_x.axes[1])

        self.nonspam_prob = ((d_y['label'] == 0).sum()) / len(d_x.index)
        self.spam_prob = ((d_y['label'] == 1).sum()) / len(d_x.index)

        df_x_Nonspam = self.class_separation(d_x, d_y, 0)
        df_x_spam = self.class_separation(d_x, d_y, 1)
        # del df_x_spam["label"]

        self.sum_over_all_values_nonspam = df_x_Nonspam.values.sum()
        self.sum_over_all_values_spam = df_x_spam.values.sum()

        columns_name = df_x_Nonspam.columns
        self.each_item_prob = pd.DataFrame(np.zeros((2, len(columns_name))), columns=columns_name)

        for i, names in enumerate(columns_name):
            self.each_item_prob.iloc[0, i] = (df_x_Nonspam[names].sum() + a) / (
                    self.sum_over_all_values_nonspam + a * V)
            self.each_item_prob.iloc[1, i] = (df_x_spam[names].sum() + a) / (self.sum_over_all_values_spam + a * V)

        self.each_item_prob = self.each_item_prob.applymap(lambda x: np.log(x))
        self.each_item_prob_T = self.each_item_prob.transpose()

        print("Multinomial Naive Bayes model with smooting is trained successfully.")

    def train_bernoulli_naive_bayes(self, d_x, d_y):

        self.nonspam_prob = ((d_y['label'] == 0).sum()) / len(d_x.index)
        self.spam_prob = ((d_y['label'] == 1).sum()) / len(d_x.index)

        df_x_Nonspam = self.class_separation(d_x, d_y, 0)
        df_x_spam = self.class_separation(d_x, d_y, 1)

        df_x_spam_bin = self.change_to_binary(df_x_spam.to_numpy())
        df_x_nonspam_bin = self.change_to_binary(df_x_Nonspam.to_numpy())

        self.each_item_prob = np.zeros((2, df_x_spam_bin.shape[1]))

        self.each_item_prob[0, :] = np.sum(df_x_nonspam_bin, axis=0) / df_x_nonspam_bin.shape[0]
        self.each_item_prob[1, :] = np.sum(df_x_spam_bin, axis=0) / df_x_spam_bin.shape[0]

        self.each_item_prob_T = np.transpose(self.each_item_prob)
        self.each_item_prob_not = 1 - self.each_item_prob
        self.each_item_prob_not_T = np.transpose(self.each_item_prob_not)

        print("Bernoulli Naive Bayes model is trained successfully.")

    def predict_bernoulli_naive_bayes(self, d_x):

        df_x = self.change_to_binary(d_x.to_numpy())
        df_x_not = 1 - df_x

        result_df = np.zeros((df_x.shape[0], 2))

        for i in range(df_x.shape[0]):
            sum_non = 0
            sum_spam = 0
            temp1 = 0
            temp2 = 0
            for j in range(df_x.shape[1]):
                if df_x[i, j] == 0:
                    temp1 = df_x_not[i, j] * (self.each_item_prob_not[0, j])
                    temp2 = df_x_not[i, j] * (self.each_item_prob_not[1, j])
                elif df_x_not[i, j] == 0:
                    temp1 = df_x[i, j] * (self.each_item_prob[0, j])
                    temp2 = df_x[i, j] * (self.each_item_prob[1, j])

                sum_non += np.log(temp1)
                sum_spam += np.log(temp2)

            result_df[i, 0] = np.log(self.nonspam_prob) + (sum_non)
            result_df[i, 1] = np.log(self.spam_prob) + (sum_spam)

        result_df[result_df == -np.inf] = - (10 ** 12)
        a = (result_df[:, 0] < result_df[:, 1]).astype(int)
        return np.transpose(a)


def main():
    x_train = pd.read_csv('x_train.csv')
    y_train = pd.read_csv('y_train.csv')
    y_train.rename(columns={"Prediction": "label"}, inplace=True)

    x_test = pd.read_csv('x_test.csv')
    y_test = pd.read_csv('y_test.csv')

    start = time.time()
    mnbCsl = Classifiers()
    mnbCsl.train_multinomial(x_train, y_train)
    outputMNB = mnbCsl.predict_multinomial(x_test)
    outputMNB["actual_label"] = y_test
    print("Results for Multinomial Naive Bayes :")
    matrixM = mnbCsl.confusion_matrix(outputMNB['predicted_label'], outputMNB['actual_label'])
    print(matrixM)
    print("------------------------------------------------------")

    smoothingcsl = Classifiers()
    smoothingcsl.train_multinomial_smoothing(x_train, y_train)
    outputsmoothing = smoothingcsl.predict_multinomial(x_test)
    outputsmoothing["actual_label"] = y_test
    print("Results for Multinomial Naive Bayes with smoothing :")
    matrixs = smoothingcsl.confusion_matrix(outputsmoothing['predicted_label'], outputsmoothing['actual_label'])
    print(matrixs)
    print("------------------------------------------------------")

    clsb = Classifiers()
    clsb.train_bernoulli_naive_bayes(x_train, y_train)
    outputB = clsb.predict_bernoulli_naive_bayes(x_test)
    outputB = outputB.reshape(-1, 1)
    out = np.append(outputB, y_test.to_numpy(), axis=1)
    out = pd.DataFrame(out, columns=['predicted_label', 'actual_label'])
    matrixB = clsb.confusion_matrix(out['predicted_label'], out['actual_label'])
    print(matrixB)

    print("------------------------------------------------------")

    elapsed = format(time.time() - start, '.4f')

    print("Execution time: ", elapsed)


if __name__ == "__main__":
    main()
